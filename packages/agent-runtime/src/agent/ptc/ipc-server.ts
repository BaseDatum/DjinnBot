/**
 * IPC Server for Programmatic Tool Calling (PTC)
 *
 * A lightweight HTTP server running on a random port inside the container.
 * Python code generated by the SDK calls `http://127.0.0.1:{port}/tool/{name}`
 * with JSON args. This server dispatches to the real AgentTool.execute() and
 * returns the result string.
 *
 * Also publishes toolStart/toolEnd events via Redis for dashboard observability.
 */

import { createServer, type Server, type IncomingMessage, type ServerResponse } from 'node:http';
import type { AgentTool } from '@mariozechner/pi-agent-core';
import type { RedisPublisher } from '../../redis/publisher.js';
import type { RequestIdRef } from '../runner.js';

export interface PtcIpcServerOptions {
  /** Map of tool name → AgentTool for dispatch. */
  tools: Map<string, AgentTool>;
  /** Redis publisher for streaming tool events to dashboard. */
  publisher: RedisPublisher;
  /** Mutable ref to current requestId (shared with runner). */
  requestIdRef: RequestIdRef;
}

export interface PtcIpcServer {
  /** Port the server is listening on. */
  port: number;
  /** Update the tool map (e.g. when MCP tools refresh). */
  updateTools(tools: Map<string, AgentTool>): void;
  /** Gracefully shut down the server. */
  close(): Promise<void>;
}

/**
 * Start the IPC HTTP server on a random available port.
 * Returns once the server is listening.
 */
async function handleRequest(
  req: IncomingMessage,
  res: ServerResponse,
  toolMap: Map<string, AgentTool>,
  publisher: RedisPublisher,
  requestIdRef: RequestIdRef,
): Promise<void> {
  // Only handle POST /tool/{toolName}
  if (req.method !== 'POST' || !req.url?.startsWith('/tool/')) {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end('Not found');
    return;
  }

  const toolName = decodeURIComponent(req.url.slice('/tool/'.length));
  const tool = toolMap.get(toolName);

  if (!tool) {
    res.writeHead(404, { 'Content-Type': 'text/plain' });
    res.end(`Tool not found: ${toolName}`);
    return;
  }

  // Read request body
  let body = '';
  try {
    body = await new Promise<string>((resolve, reject) => {
      const chunks: Buffer[] = [];
      req.on('data', (chunk: Buffer) => chunks.push(chunk));
      req.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
      req.on('error', reject);
    });
  } catch (err) {
    res.writeHead(400, { 'Content-Type': 'text/plain' });
    res.end(`Failed to read request body: ${err}`);
    return;
  }

  let params: unknown;
  try {
    params = body ? JSON.parse(body) : {};
  } catch {
    res.writeHead(400, { 'Content-Type': 'text/plain' });
    res.end('Invalid JSON body');
    return;
  }

  const toolCallId = `ptc_${toolName}_${Date.now()}`;
  const startTime = Date.now();

  // Publish toolStart event for dashboard observability
  publisher.publishEvent({
    type: 'toolStart',
    requestId: requestIdRef.current,
    toolName,
    args: params,
  } as any).catch(err => console.error('[PTC-IPC] Failed to publish toolStart:', err));

  try {
    const result = await tool.execute(toolCallId, params);

    const durationMs = Date.now() - startTime;

    // Publish toolEnd event
    publisher.publishEvent({
      type: 'toolEnd',
      requestId: requestIdRef.current,
      toolName,
      result: typeof result.content?.[0] === 'object' && 'text' in result.content[0]
        ? (result.content[0] as any).text
        : JSON.stringify(result),
      success: true,
      durationMs,
    } as any).catch(err => console.error('[PTC-IPC] Failed to publish toolEnd:', err));

    // Extract text content from the AgentToolResult
    const textParts = result.content
      .filter((c): c is { type: 'text'; text: string } => c.type === 'text')
      .map(c => c.text);

    const responseText = textParts.join('\n');

    res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
    res.end(responseText);
  } catch (err) {
    const durationMs = Date.now() - startTime;
    const errorMsg = err instanceof Error ? err.message : String(err);

    // Publish toolEnd with error
    publisher.publishEvent({
      type: 'toolEnd',
      requestId: requestIdRef.current,
      toolName,
      result: errorMsg,
      success: false,
      durationMs,
    } as any).catch(e => console.error('[PTC-IPC] Failed to publish toolEnd:', e));

    console.error(`[PTC-IPC] Tool execution error (${toolName}):`, errorMsg);
    res.writeHead(500, { 'Content-Type': 'text/plain' });
    res.end(`Tool execution error: ${errorMsg}`);
  }
}

export function startPtcIpcServer(options: PtcIpcServerOptions): Promise<PtcIpcServer> {
  let toolMap = options.tools;
  const { publisher, requestIdRef } = options;

  const server: Server = createServer((req: IncomingMessage, res: ServerResponse) => {
    // Wrap the entire handler in a promise with a top-level catch.
    // Node's http.createServer does NOT catch rejected promises from async
    // callbacks — an unhandled rejection kills the process. This ensures
    // every error returns an HTTP response instead of crashing the container.
    handleRequest(req, res, toolMap, publisher, requestIdRef).catch((fatal: unknown) => {
      console.error('[PTC-IPC] Fatal unhandled error in request handler:', fatal);
      try {
        if (!res.headersSent) {
          res.writeHead(500, { 'Content-Type': 'text/plain' });
        }
        res.end(`Internal PTC error: ${fatal instanceof Error ? fatal.message : String(fatal)}`);
      } catch {
        // Response already closed — nothing we can do
      }
    });
  });

  // Disable keep-alive timeout for fast cleanup
  server.keepAliveTimeout = 5000;

  return new Promise<PtcIpcServer>((resolve, reject) => {
    // Listen on random port, localhost only (container-internal)
    server.listen(0, '127.0.0.1', () => {
      const addr = server.address();
      if (!addr || typeof addr === 'string') {
        reject(new Error('Failed to get server address'));
        return;
      }

      const port = addr.port;
      console.log(`[PTC-IPC] Server listening on 127.0.0.1:${port}`);

      resolve({
        port,
        updateTools(newTools: Map<string, AgentTool>) {
          toolMap = newTools;
        },
        close() {
          return new Promise<void>((res, rej) => {
            server.close((err) => {
              if (err) rej(err);
              else {
                console.log(`[PTC-IPC] Server stopped`);
                res();
              }
            });
          });
        },
      });
    });

    server.on('error', reject);
  });
}
